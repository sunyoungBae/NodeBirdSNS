# 리뉴얼 강좌 소개

### Next.js

React를 사용한 프레임 워크. 실무를 위해 갖춰진게 많음. 대신에 정해진 툴안에서 해야하기 때문에 코딩의 자유도는 줄어듬.

가장 큰 장점 : SSR(server side rendering)

[전통적 SSR flow]

브라우저 ------ 프론트 서버 ------ 백엔드 서버
                                        |
                                        -----   데이터 베이스

1. 브라우저 -> 프론트 서버 : 블로그 페이지 요청
2. 프론트 서버 -> 백엔드 서버 : 블로그의 게시글 요청
3. 백엔드 서버 -> 데이터 베이스 : 실제 게시글 데이터 요청
4. 데이터 베이스 -> 백엔드 서버 : 실제 게시글 데이터 응답
5. 백엔드 서버 -> 프론트 서버 : 블로그의 게시글 응답
6. 프론트 서버 -> 브라우저 : 응답받은 데이터와 html 합쳐서 브라우저에 데이터로 응답

[SPA 방식(CSR)]
* 리액트, 뷰, 앵귤러, ... : Single Page Application 구동 방식.
* 리액트 : Single Page Application(하나의 페이지, 컴포넌트만 바꿔치기해서 눈속임)

1. 브라우저 -> 프론트 서버 : 페이지 요청
2. 프론트 서버 -> 브라우저 : 어떤 페이지를 요청하든 하나의 js, html, css 전달.
   * 화면은 그려주는데 데이터가 없음.
   * 로딩창 먼저 띄움
3. 브라우저 -> 백엔드 서버 : 블로그의 게시글 요청
4. 백엔드 서버 -> 데이터 베이스 : 실제 게시글 데이터 요청
5. 데이터 베이스 -> 백엔드 서버 : 실제 게시글 데이터 응답
6. 백엔드 서버 -> 브라우저 : 블로그의 게시글 응답.
   * 브라우저는 각각 프론트, 백엔드 서버에서 받은 데이터로 화면을 그림


# Next.js 역할 소개
* SPA 방식(CSR) : 화면은 한번만 받아오고, 그안에서 데이터만 계속 바꿔서 동작
  * 바뀐 데이터에따라 화면이 변경되긴하지만 프론트서버에 새로 요청하지 않는다.

### 장단점
SSR
* 브라우저에 한번에 데이터를 넘겨준다는 장점이 있지만 브라우저 요청-응답 플로우가 길기 때문에 로딩 속도가 길어짐
SPA
* 프론트서버에서 받은 데이터로 로딩창을 먼저 보여주고, 그사이에 백엔드 서버에서 데이터를 받아 화면을 그려줌
* 처음에 모든 화면을 다 가지고와야하기 때문에 더 느릴 수 있다.
* 화면에 로딩창이라도 뭐라도 먼저 띄워주기 때문에 SPA를 사용하는 것.
* 사용자가 빠르게 인터랙션이 필요할때 사용.

#### SPA 단점과 해결방법
단점
* 검색엔진이 미완성된 페이지라고 생각할 수 있다.(처음에 로딩창 먼저띄워주기 때문)

해결방법
* Server-side Rendering
  * 코드 스플리트 기술로 프론트 서버에서 방문한 페이지에 대한 코드만 보내주는 것이 있음
  * 두 가지
    * pre render : 검색엔진이라는 것을 알아차려서
      * 검색엔진일 때만 백엔드 서버에서 데이터를 받아 HTML을 완성해서주고
      * 일반 유저일 때는 기존의 SPA로 줌
    * server side rendering
      * 첫 방문만 전통적인 방법대로 하고 그 후 페이지 전환시 기존의 SPA로 방식 사용
* 실무시 Server-side Rendering과 코드 스플리팅을 무조건 적용해야한다.
  * 대부분의 서비스는 검색엔진에 노출이 되어야하고(server-side rendering), 사용자를 대상으로하는 페이지는 속도도 빨라하니까 코드 스플리팅이 적용되어야함.
* Next.js를 사용하지 않아도 되는 서비스
  * Admin 페이지 : 조금 느려도 됨.

# 실전 예제와 준비사항
* 프리패칭? -> 로딩 속도 향상
* 데이터 캐싱
* 수업 코드 : https://github.com/ZeroCho/react-nodebird
* Next : 9버전
* Ant : 4버전

# Next.js 실행해보기
Next.js에서는 React를 Import할 필요가 없다.

pages 폴더를 인식해서 여기 안에 있는 파일을 개별적인 코트스플리팅된 페이지 컴포넌트로 만들어준다.

# page와 레이아웃

next가 `pages`/내에 있는 파일명 그대로 컴포넌트와 1:1 매핑해서 라우팅까지 해준다.
* ex) pages/signup.js => http://localhost:3000/signup 로 접근
* 리액트는 라우터와 서버사이드 렌더링까지 설정을 해야하는 Next는 프론트 서버가 있기때문에 알아서 라우팅까지 해줌
* 폴더도 가능
  * ex) about/sunyoung.js > http://localhost:3000/about/sunyoung 로 접근
* 동적 라우팅 기능은 나중에 설명

페이지가 아닌 컴포넌트
* 재사용 또는 불필요한 렌더링을 막기 위해 보통 컴포넌트를 쪼갠다.
* 이 컴포넌트들은 폴더를 만들어 그 안에 넣으면 된다. 폴더명은 마음대로. 여기서는 `components` 폴더로 추가

레이아웃
* 각 페이지별로 다른 레이아웃 사용시 페이지를 사용할 레이아웃으로 감싸면된다.
  * `<AppLayout>`을 사용하는 경우
    ```React
    const Home = () => {
        return (
            <AppLayout>
                <div>Hello, Next!</div>
            </AppLayout>
        );
    }
    ```

prop-types
* props로 넘기는 얘들은 검사하면 좋음
* 타입스크립트를 사용하면 필요없음
* `Proptypes.node`
  * react > node 타입.
  * 화면에 그릴 수 있는것이 모두 node.

# Link와 eslint
### Link
Next는 자체적인 라우터가 존재
* `import Link from 'next/link';`

공통 메뉴에는 페이지별로 전환할 수 있는 링크를 만듬('AppLayout.js')
* `Link`컴포넌트의 `href`에 링크 주소를 적는다.
* `Link`컴포넌트 사이에 `<a>` 추가
```React
<Link href="/"><a>노드버드</a></Link>
<Link href="/profile"><a>프로필</a></Link>
```

개발모드에서는 처음 빌드 후 link를 누르면 delay 존재

### eslint
개뱔용으로만 사용되는 eslint 설치
* `npm i eslint -D`
* `npm i eslint-plugin-import -D`
* `npm i eslint-plugin-react -D`
* `npm i eslint-plugin-react-hooks -D`

코드 룰을 정해주기때문에 여러사람이 짜더라도 한사람이 짠 것처럼 될 수 있다.

.eslintrc파일을 만들어 json 형식으로 작성

# Q&A
serverside rendering을 하려면 react와 nodejs(spring, jango, ..) 둘다 필요

serverside rendering시 CORS를 신경써야한다.
* 브라우저 - 백엔드 간 요청에 CORS 설정 필요
* 브라우저(React), 프론트 서버(node), 백엔드 서버(node)..?

CSR : 프론트 서버에서 js, html, css 받고, 백엔드 서버에서 데이터를 요청해서 줄때까지 로딩.

SeverSideRendering
* 첫번째 요청시 프론트 서버가 백엔드 서버에 요청해서 데이터를 받아온다음 html, js 함께 브라우저에게 줌 

코드 스플리팅
* CSR일 때 브라우저에서 프론트 서버 갔다가 올때 데이터 없이 돌려줌. html, js에 모든 화면까지 다 돌려줌
* 그래서 js파일을 쪼개서 요청에 맞는 페이지에 대한 정보만 줌
* 부분적으로 받아왔기때문에 프론트 서버와 요청이 중간중간에 잇음

리액트를 하는 주된 목적은 고객의 경험이 좋아지기 때문이다.

서버사이드 렌더링을 하는 목적은 검색 엔진에 나와야해서 하는 것임.
* 로딩을 없애는 이유로도 사용해도 됨.
